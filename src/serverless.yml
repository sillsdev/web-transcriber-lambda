custom:
    myStage: ${opt:stage, self:provider.stage}  #use the --stage CLI option if it exists, or use provider.stage
    isDebug: ${opt:debug, ""}
    stagedMessage:
        dev: "DEV"
        devx: "DEV"
        qa: "QA"
        prod: "PROD"
    userName: ${file(./serverless.env.yml):xxx.MasterUsername}
    pwd: ${file(./serverless.env.yml):xxx.MasterUserPassword}

service: transcriberAPI
configValidationMode: warn
#frameworkVersion: ^3.19.0

provider:
  name: aws
  runtime: dotnet6
  region: us-east-1
  stage: qa     #cli build params will override this!!
  profile: transcriber  #aws credentials file 
  stackName: TranscriberStack${self:custom.myStage}${self:custom.isDebug}
 # deploymentBucket:
 #   name: sil-transcriber-lead-api # Deployment bucket name. Default is generated by the framework
  environment:
    SIL_TR_CONNECTIONSTRING: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_CONNECTIONSTRING}
    SIL_TR_ORIGINSITES: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_ORIGINSITES}
    SIL_TR_AUTH0_DOMAIN: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_DOMAIN}
    SIL_TR_AUTH0_AUDIENCE: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_AUDIENCE}
    SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_ID: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_ID}
    SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_SECRET: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_SECRET}
    SIL_TR_USERFILES_BUCKET: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_USERFILES_BUCKET}
    SIL_TR_PUBLISHREQ_BUCKET: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_PUBLISHREQ_BUCKET}
    SIL_TR_PUBLISHED_BUCKET: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_PUBLISHED_BUCKET}
    SIL_TR_PARATEXT_CLIENT_ID:  ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_PARATEXT_CLIENT_ID}
    SIL_TR_PARATEXT_CLIENT_SECRET:  ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_PARATEXT_CLIENT_SECRET}
    SIL_TR_PARATEXT_AUTH0_CONNECTION:  ${file(./serverless.env.yml):xxx.SIL_TR_PARATEXT_AUTH0_CONNECTION}
    SIL_TR_PARATEXT_DATA:   ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_PARATEXT_DATA}
    SIL_TR_PARATEXT_REGISTRY:   ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_PARATEXT_REGISTRY}
    SIL_TR_EMAIL_FROM:  ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_EMAIL_FROM}
    SIL_TR_EMAIL_HOST:  ${file(./serverless.env.yml):xxx.SIL_TR_EMAIL_HOST}
    SIL_TR_WEBHOOK_USERNAME:   ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_WEBHOOK_USERNAME}
    SIL_TR_WEBHOOK_PASSWORD:   ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_WEBHOOK_PASSWORD}
    ASPNETCORE_ENVIRONMENT: ${file(./serverless.env.yml):${self:custom.myStage}.ASPNETCORE_ENVIRONMENT}
    SIL_TR_EXPORT_QUEUE:  ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_EXPORT_QUEUE}
    SIL_TR_BIBLEBRAIN:  ${file(./serverless.env.yml):xxx.SIL_TR_BIBLEBRAIN}
    SIL_TR_BIBLEBRAIN_QUEUE:  ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_BIBLEBRAIN_QUEUE}
    SIL_TR_AQUIFER:  ${file(./serverless.env.yml):xxx.SIL_TR_AQUIFER}
    SIL_TR_AQUA_PASSWORD: ${file(./serverless.env.yml):xxx.SIL_TR_AQUA_PASSWORD}


package:
  artifact: bin/release/net6.0/deploy-package_${self:custom.myStage}.zip

functions:
  api:
    handler: TranscriberApi::SIL.Transcriber.LambdaEntryPoint::FunctionHandlerAsync
    name: transcriber_api_${self:custom.myStage}${self:custom.isDebug}
    timeout: 30
    events:
       - http:
            path: /api/{proxy+}
            method: ANY
            cors:
             origin: '*'
             headers:
              - X-Fp
              - Content-Type
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - X-Amz-User-Agent



##If the X-Fp header is not working (totally guessed on the cors stuff above)
##go to aws console, API Gateway, choose api
##Resources -> /{proxy} -> Actions Enable Cors
## Add X-Fp, to Access-Control-Allow-Headers
## Push "Enable cors and replace existing cors headers" button
##This doesn't work...so go create this s3 bucket manually
# Further instructions in file AWSConfig.txt

## Create S3 bucket for userfiles
##   transcribers3:
##    Type: AWS::S3::Bucket
##    Properties: 
##      BucketName: sil-transcriber-userfiles-${self:custom.myStage}
##    CORSConfiguration>: 
##        '<?xml version="1.0" encoding="UTF-8"?>
##        <CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
##        <CORSRule>
##            <AllowedOrigin>*</AllowedOrigin>
##            <AllowedMethod>GET</AllowedMethod>
##            <AllowedMethod>PUT</AllowedMethod>
##            <AllowedMethod>DELETE</AllowedMethod>
##            <AllowedHeader>*</AllowedHeader>
##        </CORSRule>
##        </CORSConfiguration>'