custom:
    myStage: ${opt:stage, self:provider.stage}  #use the --stage CLI option if it exists, or use provider.stage
    stagedMessage:
        dev: "DEV"
        qa: "QA"
        prod: "PROD"

service: transcriber_api

provider:
  name: aws
  runtime: dotnetcore2.1
  region: us-east-2
  stage: qa     #cli build params will override this!!
  stackName: TranscriberStack${self:custom.myStage}
  deploymentBucket:
    name: sil-transcriber-lead-api # Deployment bucket name. Default is generated by the framework
  environment:
    ConnectionString: ${file(./serverless.env.yml):${opt:stage}.ConnectionString}
    OriginSites: "*"
    AUTH0_DOMAIN: ${file(./serverless.env.yml):${self:custom.myStage}.AUTH0_DOMAIN}
    AUTH0_AUDIENCE: ${file(./serverless.env.yml):${self:custom.myStage}.AUTH0_AUDIENCE}
    AUTH0_TOKEN_ACCESS_CLIENT_ID: ${file(./serverless.env.yml):${self:custom.myStage}.AUTH0_TOKEN_ACCESS_CLIENT_ID}
    AUTH0_TOKEN_ACCESS_CLIENT_SECRET: ${file(./serverless.env.yml):${self:custom.myStage}.AUTH0_TOKEN_ACCESS_CLIENT_SECRET}

deploymentPrefix: AWSTranscriberAPI/
package:
  artifact: bin/release/netcoreapp2.1/deploy-package_${self:custom.myStage}.zip

functions:
  api:
    handler: TranscriberApi::SIL.Transcriber.LambdaEntryPoint::FunctionHandlerAsync
    name: transcriber_api_${self:custom.myStage}
    events:
       - http:
            path: /api/{proxy+}
            method: ANY
            cors: true  #this doesn't actually work with proxy above but leave it in here as a note that we want cors
 

# Create our resources with separate CloudFormation templates
resources:
  # API Gateway Errors
  - ${file(resources/api-gateway-errors.yml)}
 