custom:
    myStage: ${opt:stage, self:provider.stage}  #use the --stage CLI option if it exists, or use provider.stage
    stagedMessage:
        dev: "DEV"
        qa: "QA"
        prod: "PROD"
    userName: ${file(./serverless.env.yml):${self:custom.myStage}.MasterUsername}
    pwd: ${file(./serverless.env.yml):${self:custom.myStage}.MasterUserPassword}

service: transcriber_api

provider:
  name: aws
  runtime: dotnetcore2.1
  region: us-east-1
  stage: qa     #cli build params will override this!!
  profile: transcriber  #aws credentials file 
  stackName: TranscriberStack${self:custom.myStage}
 # deploymentBucket:
 #   name: sil-transcriber-lead-api # Deployment bucket name. Default is generated by the framework
  environment:
    SIL_TR_CONNECTIONSTRING: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_CONNECTIONSTRING}
    SIL_TR_ORIGINSITES: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_ORIGINSITES}
    SIL_TR_AUTH0_DOMAIN: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_DOMAIN}
    SIL_TR_AUTH0_AUDIENCE: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_AUDIENCE}
    SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_ID: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_ID}
    SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_SECRET: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_AUTH0_TOKEN_ACCESS_CLIENT_SECRET}
    SIL_TR_USERFILES_BUCKET: ${file(./serverless.env.yml):${self:custom.myStage}.SIL_TR_USERFILES_BUCKET}
deploymentPrefix: AWSTranscriberAPI/
package:
  artifact: bin/release/netcoreapp2.1/deploy-package_${self:custom.myStage}.zip

functions:
  api:
    handler: TranscriberApi::SIL.Transcriber.LambdaEntryPoint::FunctionHandlerAsync
    name: transcriber_api_${self:custom.myStage}
    timeout: 30
    events:
       - http:
            path: /api/{proxy+}
            method: ANY
            cors: true  #this doesn't actually work with proxy above but leave it in here as a note that we want cors
 

# Create our resources with separate CloudFormation templates
resources:
  Resources:
## Create database - needs VPC with two subnets
   transcriberlambdavpc:
      Type: AWS::EC2::VPC
      Properties:
        CidrBlock: "10.0.0.0/16"

   transcriberlambdasubnetA:
      DependsOn: transcriberlambdavpc
      Type: AWS::EC2::Subnet
      Properties:
        VpcId:
          Ref: transcriberlambdavpc
        AvailabilityZone: ${self:provider.region}a
        CidrBlock: "10.0.0.0/24"

   transcriberlambdasubnetB:
      DependsOn: transcriberlambdavpc
      Type: AWS::EC2::Subnet
      Properties:
        VpcId:
          Ref: transcriberlambdavpc
        AvailabilityZone: ${self:provider.region}b
        CidrBlock: "10.0.1.0/24"

   transcriberlambdasg:
      DependsOn: transcriberlambdavpc
      Type: AWS::EC2::SecurityGroup
      Properties:
        GroupDescription: SecurityGroup for Serverless Functions
        VpcId:
          Ref: transcriberlambdavpc

   transcriberdatasg:
      DependsOn: transcriberlambdavpc
      Type: AWS::EC2::SecurityGroup
      Properties:
        GroupDescription: SecurityGroup for RDS Instance
        VpcId:
          Ref: transcriberlambdavpc
        SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: '5432'
          ToPort: '5432'
          SourceSecurityGroupId:
            Ref: transcriberlambdasg
        - IpProtocol: tcp
          FromPort: '11211'
          ToPort: '11211'
          SourceSecurityGroupId:
            Ref: transcriberlambdasg
        - IpProtocol: tcp
          FromPort: '5432'
          ToPort: '5432'
          CidrIp: 0.0.0.0/0
          
   transcriberdatasubnet:
      Type: AWS::RDS::DBSubnetGroup
      Properties:
        DBSubnetGroupDescription: "RDS Subnet Group"
        SubnetIds:
        - Ref: transcriberlambdasubnetA
        - Ref: transcriberlambdasubnetB
#Create the RDS Cluster and database -- naming it doesn't work so rename manually if desired
   transcriberrdscluster:
      Type: AWS::RDS::DBInstance
      Properties:
        #DBClusterIdentifier: transdata${self:custom.myStage}
        Engine: Postgres
        DBName: transcriberdb
        MasterUsername: ${self:custom.userName}
        MasterUserPassword: ${self:custom.pwd}
        DBInstanceClass: db.t3.micro
        AllocatedStorage: 10
        VPCSecurityGroups:
        - "Fn::GetAtt": transcriberdatasg.GroupId
        DBSubnetGroupName:
          Ref: transcriberdatasubnet

# API Gateway Errors
#  - ${file(resources/api-gateway-errors.yml)}
   GatewayResponseDefault4XX:
     Type: 'AWS::ApiGateway::GatewayResponse'
     Properties:
       ResponseParameters:
         gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
         gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
       ResponseType: DEFAULT_4XX
       RestApiId:
         Ref: 'ApiGatewayRestApi'
   GatewayResponseDefault5XX:
     Type: 'AWS::ApiGateway::GatewayResponse'
     Properties:
       ResponseParameters:
         gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
         gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
       ResponseType: DEFAULT_5XX
       RestApiId:
         Ref: 'ApiGatewayRestApi'

##This doesn't work...so go create this s3 bucket manually
# Further instructions in file AWSConfig.txt

## Create S3 bucket for userfiles
##   transcribers3:
##    Type: AWS::S3::Bucket
##    Properties: 
##      BucketName: sil-transcriber-userfiles-${self:custom.myStage}
##    CORSConfiguration>: 
##        '<?xml version="1.0" encoding="UTF-8"?>
##        <CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
##        <CORSRule>
##            <AllowedOrigin>*</AllowedOrigin>
##            <AllowedMethod>GET</AllowedMethod>
##            <AllowedMethod>PUT</AllowedMethod>
##            <AllowedMethod>DELETE</AllowedMethod>
##            <AllowedHeader>*</AllowedHeader>
##        </CORSRule>
##        </CORSConfiguration>'
